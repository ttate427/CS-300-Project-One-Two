# CS-300-Project-One-Two
In these projects, the main problem I was solving was how to efficiently store, organize, and retrieve course information for a Computer Science advising program. The challenge was not only in implementing functionality such as searching, sorting, and printing courses, but also in evaluating which data structures best supported these operations in terms of runtime efficiency and memory usage.
To approach this problem, I explored different data structures including vectors, hash tables, and binary search trees. Each offered unique advantages and trade-offs, and working through them reinforced why data structures are critical to understand in software design. For example, vectors are simple and memory-efficient but inefficient for frequent lookups, while hash tables provide near-constant time lookups but require more memory, and binary search trees offer naturally sorted data but can degrade in performance if unbalanced. By experimenting with these structures, I was able to see firsthand how design decisions directly affect program performance and usability.
One roadblock I encountered was ensuring that prerequisites and course lookups worked correctly across the different implementations. Debugging logic errors and validating file input required careful testing and step-by-step tracing. To overcome this, I broke the problem down into smaller components—first ensuring file reading worked correctly, then validating data, and finally implementing lookups and sorting. This stepwise approach helped me resolve issues without becoming overwhelmed.
Working on these projects has expanded my approach to designing software by making me more intentional in my choice of data structures and algorithms. Instead of just writing code that “works,” I now consider how scalable and efficient my design will be as data grows. This experience has also influenced the way I write programs: I now focus on making my code more maintainable, readable, and adaptable. For example, I used clear function names, structured my program into logical parts, and kept the code flexible enough to support new features in the future. These habits will carry forward into my future projects, where readability and adaptability are just as important as raw functionality.
